# 动态代理

## JDK静态代理

### 静态代理基本实现

创建一个接口，然后创建被代理的类实现该接口并且实现该接口中的抽象方法。之后再创建一个代理类，同时使其也实现这个接口。在代理类中持有一个被代理对象的引用，而后在代理类方法中调用该对象的方法。

其实就是代理类为被代理类预处理消息、过滤消息并在此之后将消息转发给被代理类，之后还能进行消息的后置处理.

```java
public class Client {

    public static void main(String[] args) {
        HelloProxy helloProxy = new HelloProxy();
        helloProxy.sayHello();
    }

    static class HelloProxy implements HelloWorldInterface {
        private HelloWorldInterface helloWorldInterface = new HelloWorldImpl();

        @Override
        public void sayHello() {
            System.out.println("before invoke static ");
            helloWorldInterface.sayHello();
            System.out.println("after invoke static ");
        }
    }
}
```



### 静态代理缺点

使用JDK静态代理很容易就完成了对一个类的代理操作。但是JDK静态代理的缺点也暴露了出来：由于代理只能为一个类服务，如果需要代理的类很多，那么就需要编写大量的代理类，比较繁琐。我们可以使用动态代理解决.

JDK静态代理是通过直接编码创建的，而JDK动态代理是利用反射机制在运行时创建代理类的。

## JDK动态代理

### 动态代理简介

其实在动态代理中，核心是InvocationHandler。每一个代理的实例都会有一个关联的调用处理程序(InvocationHandler).

InvocationHandler会保存实际的target对象.

对待代理实例(Proxy)进行调用时，将对方法的调用进行编码并指派到它的调用处理器(InvocationHandler)的invoke方法。所以对代理对象实例方法的调用都是通过InvocationHandler中的invoke方法来完成的，而invoke方法会根据传入的代理对象、方法名称以及参数决定调用代理的哪个方法。

### 基本实现

```java
HelloWorldInterface helloWorld =  (HelloWorldInterface) Proxy.newProxyInstance(DynamicProxyLearn.class.getClassLoader()
                ,new Class<?>[]{HelloWorldInterface.class}
                , new HelloWorldInvocationHandler(new HelloWorldImpl())
                );
        helloWorld.sayHello();
```



### 动态代理的缺点

只能代理接口



Proxy    Invocationhandler  Impl

### 参考

https://www.jianshu.com/p/471c80a7e831

http://www.importnew.com/23168.html

http://blog.jobbole.com/104433/