## CGLIB简介

CGLIB(Code Generation Library)是一个开源项目！是一个强大的，高性能，高质量的Code生成类库，

它可以在运行期扩展Java类与实现Java接口。Hibernate用它来实现PO(Persistent Object 持久化对象)字节码的动态生成。

CGLIB是一个强大的高性能的代码生成包。它广泛的被许多AOP的框架使用，例如Spring AOP为他们提供方法的interception（拦截）。CGLIB包的底层是通过使用一个小而快的字节码处理框架ASM，来转换字节码并生成新的类。

除了CGLIB包，脚本语言例如Groovy和BeanShell，也是使用ASM来生成java的字节码。当然不鼓励直接使用ASM，

因为它要求你必须对JVM内部结构包括class文件的格式和指令集都很熟悉。




## 使用

### 被代理类

```java
public class HelloWorld {
    public HelloWorld() {
        System.out.println("HelloWorld构造");
    }

    /**
     * 该方法不能被子类覆盖,Cglib是无法代理final修饰的方法的，当然类是final也无法代理
     */
    final public String sayOthers(String name) {
        System.out.println("HelloWorld:sayOthers:" + name);
        return null;
    }

    public void sayHello() {
        System.out.println("HelloWorld:sayHello");
    }

}
```





### 拦截器

```java
public class MyMethodInterceptor implements MethodInterceptor {

    /**
     *
     * @param proxy cglib生成的代理类实例
     * @param method 被代理对象方法
     * @param objects 方法参数
     * @param methodProxy 代理方法对象
     * @return
     * @throws Throwable
     */
    @Override
    public Object intercept(Object proxy, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
        System.out.println("======插入前置通知======");
        Object object = methodProxy.invokeSuper(proxy, objects);
        System.out.println("======插入后者通知======");
        return object;

    }
}
```



### 测试类

```java
public class CglibDynamicProxyLearn {

    public static void main(String[] args) {
        // 代理类class文件存入本地磁盘方便我们反编译查看源码
        System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, "/Users/xxx/Documents/我的坚果云/project/java-learn/cglib");
        // 通过CGLIB动态代理获取代理对象的过程
        Enhancer enhancer = new Enhancer();
        // 代理类需要继承目标类使用的是extend实现代理）
        enhancer.setSuperclass(HelloWorld.class);
        // 加强类设置代理类，当拦截到目标类的方法调用，用这个代理的intercept方法对原方法加强
        enhancer.setCallback(new MyMethodInterceptor());
        // 创建代理对象（这里的helloWorld才叫做代理对象）
        HelloWorld proxy= (HelloWorld)enhancer.create();
        // 通过代理对象调用目标方法
        proxy.sayHello();

    }
}
```



## 原理

cglib使用继承的方式实现代理.

看一个实例.

```java
public class HelloWorld$$EnhancerByCGLIB$$c71a873 extends HelloWorld implements Factory {
     // MethodInterceptor对象
     private MethodInterceptor CGLIB$CALLBACK_0;
    .....
    public final void sayHello() {
        MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;
        if (var10000 == null) {
            CGLIB$BIND_CALLBACKS(this);
            var10000 = this.CGLIB$CALLBACK_0;
        }

        if (var10000 != null) {
            //实际调用MethodInterceptor对象的拦截方法
            var10000.intercept(this, CGLIB$sayHello$0$Method, CGLIB$emptyArgs, CGLIB$sayHello$0$Proxy);
        } else {
            super.sayHello();
        }
    }
    .....
}
```



上述代码我们看到，当调用代理对象的`sayHello()`方法时，首先会尝试转发给`MethodInterceptor.intercept()`方法，如果没有`MethodInterceptor`就执行父类的`sayHello()`。这些逻辑没什么复杂之处，但是他们是在运行时动态产生的，无需我们手动编写。如何获取CGLIB代理类字节码可参考   
[`Access the generated byte[] array directly`](https://github.com/cglib/cglib/wiki/How-To#access-the-generated-byte-array-directly)。

更多关于CGLIB的介绍可以参考Rafael Winterhalter的[cglib: The missing manual](https://dzone.com/articles/cglib-missing-manual)，一篇很深入的文章。







## 参考

https://blog.csdn.net/yhl_jxy/article/details/80633194