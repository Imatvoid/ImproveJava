## CGLIB简介

CGLIB(Code Generation Library)是一个开源项目！是一个强大的，高性能，高质量的Code生成类库.

它可以在运行期扩展Java类与实现Java接口。Hibernate用它来实现PO(Persistent Object 持久化对象)字节码的动态生成。

CGLIB是一个强大的高性能的代码生成包。它广泛的被许多AOP的框架使用，例如Spring AOP为他们提供方法的interception（拦截）。CGLIB包的底层是通过使用一个小而快的字节码处理框架ASM，来转换字节码并生成新的类。

除了CGLIB包，脚本语言例如Groovy和BeanShell，也是使用ASM来生成java的字节码。当然不鼓励直接使用ASM，

因为它要求你必须对JVM内部结构包括class文件的格式和指令集都很熟悉。

## 使用

与JDK动态代理相比，cglib可以实现对一般类的代理而无需实现接口。在上例中通过下列步骤来生成目标类Target的代理类：

1. 创建Enhancer实例
2. 通过setSuperclass方法来设置目标类
3. 通过setCallback 方法来设置拦截对象
4. create方法生成Target的代理类，并返回代理类的实例

### 被代理类

```java
public class HelloWorld {
    public HelloWorld() {
        System.out.println("HelloWorld构造");
    }

    /**
     * 该方法不能被子类覆盖,Cglib是无法代理final修饰的方法的，当然类是final也无法代理
     */
    final public String sayOthers(String name) {
        System.out.println("HelloWorld:sayOthers:" + name);
        return null;
    }

    public void sayHello() {
        System.out.println("HelloWorld:sayHello");
    }

}
```

### 拦截器

```java
public class MyMethodInterceptor implements MethodInterceptor {

    /**
     *
     * @param proxy cglib生成的代理类实例
     * @param method 被代理对象方法
     * @param objects 方法参数
     * @param methodProxy 代理方法对象
     * @return
     * @throws Throwable
     */
    @Override
    public Object intercept(Object proxy, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
        System.out.println("======插入前置通知======");
        Object object = methodProxy.invokeSuper(proxy, objects);
        System.out.println("======插入后者通知======");
        return object;

    }
}
```

### 测试类

```java
public class CglibDynamicProxyLearn {

    public static void main(String[] args) {
        // 代理类class文件存入本地磁盘方便我们反编译查看源码
        System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, "/Users/xxx/Documents/我的坚果云/project/java-learn/cglib");
        // 通过CGLIB动态代理获取代理对象的过程
        Enhancer enhancer = new Enhancer();
        // 代理类需要继承目标类使用的是extend实现代理）
        enhancer.setSuperclass(HelloWorld.class);
        // 加强类设置代理类，当拦截到目标类的方法调用，用这个代理的intercept方法对原方法加强
        enhancer.setCallback(new MyMethodInterceptor());
        // 创建代理对象（这里的helloWorld才叫做代理对象）
        HelloWorld proxy= (HelloWorld)enhancer.create();
        // 通过代理对象调用目标方法
        proxy.sayHello();

    }
}
```

上述代码中，我们通过CGLIB的`Enhancer`来指定要代理的目标对象、实际处理代理逻辑的对象，最终通过调用`create()`方法得到代理对象，**对这个对象所有非final方法的调用都会转发给`MethodInterceptor.intercept()`方法**，在`intercept()`方法里我们可以加入任何逻辑，比如修改方法参数，加入日志功能、安全检查功能等；通过调用`MethodProxy.invokeSuper()`方法，我们将调用转发给原始对象.

> 对于从Object中继承的方法，CGLIB代理也会进行代理，如`hashCode()`、`equals()`、`toString()`等，但是`getClass()`、`wait()`等方法不会，因为它是final方法，CGLIB无法代理。



## 原理

### 代理类

cglib使用继承的方式实现代理.

看一个实例.

```java
public class HelloWorld$$EnhancerByCGLIB$$c71a873 extends HelloWorld implements Factory {
     // MethodInterceptor对象
     private MethodInterceptor CGLIB$CALLBACK_0;
    .....
    // 直接调用父类的方法  
    final void CGLIB$sayHello$0() {
        super.sayHello();
    }  
    // 注意是final
    public final void sayHello() {
        MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;
        if (var10000 == null) {
            CGLIB$BIND_CALLBACKS(this);
            var10000 = this.CGLIB$CALLBACK_0;
        }
        if (var10000 != null) {
            //实际调用MethodInterceptor对象的拦截方法
            var10000.intercept(this, CGLIB$sayHello$0$Method, CGLIB$emptyArgs, CGLIB$sayHello$0$Proxy);
        } else {
            super.sayHello();
        }
    }
    .....
}
```

上述代码我们看到，当调用代理对象的`sayHello()`方法时，首先会尝试转发给`MethodInterceptor.intercept()`方法，如果没有`MethodInterceptor`就执行父类的`sayHello()`。这些逻辑没什么复杂之处，但是他们是在运行时动态产生的，无需我们手动编写。如何获取CGLIB代理类字节码可参考   
[`Access the generated byte[] array directly`](https://github.com/cglib/cglib/wiki/How-To#access-the-generated-byte-array-directly)。

更多关于CGLIB的介绍可以参考Rafael Winterhalter的[cglib: The missing manual](https://dzone.com/articles/cglib-missing-manual)，一篇很深入的文章。



### Fastclass简介

**Jdk动态代理的拦截对象是通过反射的机制来调用被拦截方法的，反射的效率比较低，所以cglib采用了FastClass的机制来实现对被拦截方法的调用**。FastClass机制就是对一个类的方法建立索引，通过索引来直接调用相应的方法，下面用一个小例子来说明一下，这样比较直观：

```java
package com.learn.java.proxy.dynamic.fastclass;

public class Test {
    public static void main(String[] args) {
        Class1 class1 = new Class1();
        FastClass fc = new FastClass();
        int index = fc.getIndex("f()V");
        fc.invoke(index, class1, null);
    }
}

class Class1 {
    public void f() {
        System.out.println("f method");
    }
    public void g() {
        System.out.println("g method");
    }
}

class FastClass {
    public Object invoke(int index, Object o, Object[] ol) {
        Class1 t = (Class1) o;
        switch (index) {
            case 1:
                t.f();
                return null;
            case 2:
                t.g();
                return null;
        }
        return null;
    }

    public int getIndex(String signature) {
        switch (signature.hashCode()) {
            case 3078479:
                return 1;
            case 3108270:
                return 2;
        }
        return -1;
    }
}
```

类FastClass是类Class1的Fastclass，在FastClass中有两个方法getIndex和invoke。在getIndex方法中对Class1的每个方法建立索引，并根据入参（方法名+方法的描述符）来返回相应的索引。Invoke根据指定的索引，以ol为入参调用对象o的方法。这样就避免了反射调用，提高了效率。

### fastclass分析

参考:

https://juejin.im/post/5b3e05caf265da0f652364ce

[https://www.throwable.club/2018/12/16/cglib-dynamic-proxy-analyze/#CGLIB%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90-1](https://www.throwable.club/2018/12/16/cglib-dynamic-proxy-analyze/#CGLIB动态代理原理分析-1)

https://blog.csdn.net/Mr_SeaTurtle_/article/details/52741283

https://www.cnblogs.com/cruze/p/3865180.html





## 参考

https://www.cnblogs.com/carpenterlee/p/8241042.html

https://blog.csdn.net/yhl_jxy/article/details/80633194