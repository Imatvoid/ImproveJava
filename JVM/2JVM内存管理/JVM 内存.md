## JVM运行时数据区域

![1563694957224](assets/JVM 内存/1563694957224.png)


### 线程独有--程序计数器

程序计数器(Program Counter Register)是一块较小的内存空间,它可以看作是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里(仅是概念模型,各种虚拟机可能会通过一些更高效的方式去实现),字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令,分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

由于Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，**每条线程都需要有一个独立的程序计数器**，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为**“线程私有”的内存**。

如果线程正在执行的是一个**Java方法**,这个计数器记录的是**正在执行的虚拟机字节码指令的地址**;

如果线程正在执行的是一个**Native方法**,这个计数器值则为**空(Undefined)**。

此内存区域是唯一一个在Java虚拟机规范中**没有规定任何OutOfMemoryError情况的区域**。

### 线程独有--Java虚拟机栈

与程序计数器一样,**Java虚拟机栈(Java Virtual Machine Stacks)也是线程私有的**,它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型:

每个方法在执行的同时都会创建**一个栈帧(Stack Frame )用于存储局部变量表、操作数栈、动态链接、方法出口**
**等信息**。每一个方法从调用直至执行完成的过程,就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。

局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int foat、long、double）、对象引用（reference 类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和 return address类型（指向了一条字节码指令的地址）。

**StackOverFlow/OOM**

在Java虚拟机规范中,对这个区域规定了两种异常状况:如果线程请求的栈深度大于虚拟机所允许的深度,将抛出StackOverflowError异常;如果虚拟机栈可以动态扩展(当前大部分的Java虚拟机都可动态扩展,只不过Java虚拟机规范中也允许固定长度的虚拟机栈),如果扩展时无法申请到足够的内存,就会抛出OutOfMemoryError异常。

### 线程独有--本地方法栈

本地方法栈(Native Method Stack)与虚拟机栈所发挥的作用是非常相似的,它们之间的区别不过是虚拟机栈为虚拟机执行Java方法(也就是字节码)服务,而本地方法栈则为虚拟机使用到的Native方法服务。

**Sun Hotspot 虚拟机直接就把本地方法栈和虚拟机栈合ニ为ー。与虚拟机栈一样，本地方法栈区域也会抛出 StackoverflowError和 OutofMemoryError异常。**

### 共享 -- 堆

对于大多数应用来说,Java堆(Java Heap)是Java虚拟机所管理的内存中最大的一块。
**Java堆/GC堆是被所有线程共享的一块内存区域**,在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例,几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是:所有的对象实例以及数组都要在堆上分配 ,但是随着JIT编译器的发展与逃逸分析技术逐渐成熟,栈上分配、标量替换优化技术将会导致一些微妙的变化发生,所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。

### 共享 -- 方法区(非堆)

#### 简介

**方法区(Method Area)与Java堆一样,是各个线程共享的内存区域**,它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分,但是它却有一个别名叫做Non-Heap(非堆),目的应该是与Java堆区分开来。

#### 运行时常量池

运行时常量池(Runtime Constant Pool)是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外,还有一项信息是常量池(Constant Pool Table),用于存放编译期生成的各种字面量和符号引用,这部分内容将在类加载后进入方法区的运行时常量池中存放。



根据Java虚拟机规范的规定,当方法区无法满足内存分配需求时,将抛出
OutOfMemoryError异常。

### 本地内存 -- 元数据区metas pace

后面有提到,jdk1.8 后用于实现方法区和其他特性.

### 本地内存 -- 直接内存

直接内存(Direct Memory)并不是虚拟机运行时数据区的一部分,也不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用,而且也可能导致OutOfMemoryError异常出现,所以我们放到这里一起讲解。
在JDK 1.4中新加入了NIO(New Input/Output)类,引入了一种基于通道(Channel)与缓冲区(Buffer)的I/O方式,它可以**使用Native函数库直接分配堆外内存**,然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能,因为避免了在Java堆和Native堆中来回复制数据。

显然,本机直接内存的分配不会受到Java堆大小的限制,但是,既然是内存,肯定还是会受到本机总内存(包括RAM以及SWAP区或者分页文件)大小以及处理器寻址空间的限制。

服务器管理员在配置虚拟机参数时,会根据实际内存设置-Xmx等参数信息,但经常忽略直接内存,使得各个内存区域总和大于物理内存限制(包括物理的和操作系统级的限制),从而导致动态扩展时出现OutOfMemoryError异常。

**1. Direct buffer是相当于固定的内核buffer还是JVM进程内的堆外内存？**

JVM进程的Java堆外申请的内存，是用户空间的，这是毫无疑问的，DirectByteBuffer的创建就是使用了 malloc 申请的内存。

**2. 为什么在执行网络IO或者文件IO时，一定要通过堆外内存呢？**

如果是非DirectBuffer，JDK会先创建一个DirectBuffer，再去执行真正的写操作。这是因为，当我们把一个地址通过JNI传递给底层的C库的时候，有一个基本的要求，就是这个地址上的内容不能失效。然而，在GC管理下的对象是会在Java堆中移动的。也就是说，有可能我把一个地址传给底层的write，但是这段内存却因为GC整理内存而失效了。所以我必须要把待发送的数据放到一个GC管不着的地方。这就是调用native方法之前，数据一定要在堆外内存的原因。

>  -XX:MaxDirectMemorySize来指定最大的堆外内存大小

**3.DirectByteBuffer 指向的 native memory 是不受 GC 管辖的 如何回收**

在 DirectByteBuffer 的构造方法中创建了一个 Cleaner,Cleaner 类继承了 PhantomReference 类，当 DirectByteBuffer 被 GC 之前 cleaner 对象会被放入一个引用队列（ReferenceQueue），JVM 会启动一个低优先级线程扫描这个队列，并且执行 Cleaner 的 clean 方法来做清理工作。

## 版本变化

jdk8后.

![image-20190917120702131](assets/JVM 内存/image-20190917120702131.png)



**方法区有不同实现方式**

在Java 7及之前版本，我们也习惯称方法区它为“永久代”（Permanent Generation），更确切来说，应该是“HotSpot使用永久代实现了方法区”！jdk 8**元数据区**取代了永久代.

方法区只是JVM规范定义，而永久代为具体的实现，元空间也是方法区在jdk1.8中的一种实现。

**元数据区实现方法区**

**元数据区取代了永久代**，就是JDK8没有了**PermSize**相关的参数配置了。元空间的本质和永久代类似，都是对JVM规范中方法区的实现。

不过元空间与永久代之间最大的区别在于：**元数据空间并不在虚拟机中，而是使用本地内存**。

> 为什么废除永久代？
>
> 1.官方文档：移除永久代是为融合HotSpot JVM与 JRockit VM而做出的努力，因为JRockit没有永久代，不需要配置永久代
>
> 2.PermGen很难调整，应该为PermGen分配多大的空间很难确定，因为PermSize的大小依赖于很多因素，比如JVM加载的class总数，常量池的大小，方法的大小等。
>
> PermGen中类的元数据信息在每次FullGC的时候可能被收集，但成绩很难令人满意。并且永久代内存经常不够用发生内存泄露。

**运行时常量池变化**

在近三个JDK版本（1.6、1.7、1.8）中， 运行时常量池（Runtime Constant Pool）的所处区域一直在不断的变化，在JDK1.6时它是方法区的一部分；1.7又把他放到了堆内存中；1.8之后出现了元空间，它又回到了方法区。其实，这也说明了官方对“永久代”的优化从1.7就已经开始了。



## 内存中的对象

### 对象的创建过程

#### 时机

克隆 反序列化 new

#### 1.检查类加载

虚拟机遇到一条new指令时,首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用,并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有,那必须先执行相应的类加载过程.

#### 2.分配内存

从java堆中划分一块区域:

- 指针碰撞

  假设 Java 堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”（Bump the Pointer）。

- 空闲列表,标记哪块可以用

保证并发安全:

   - CAS CAS配上失败重试的方式保证更新操作的原子性

   - TLAB

     另一种是把内存分配的动作按照线程划分在不同的空间之中进行,即每个线程在Java堆中预先分配一小块内
     存,称为本地线程分配缓冲(Thread Local Allocation Buffer,TLAB).

#### 3.初始化对象头

例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头(Object Header)之中。根据虚拟机当前的运行状态的不同,如是否启用偏向锁等,对象头会有不同的设置方式。

#### 4.初始化对象

在上面工作都完成之后,从虚拟机的视角来看,一个新的对象已经产生了,但从Java程序的视角来看,对象创建才刚刚开始——<init>方法还没有执行,所有的字段都还为零。所以,一般来说(由字节码中是否跟随invokespecial指令所决定),执行new指令之后会接着执行<init>方法,把对象按照程序员的意愿进行初始化,这样一个真正可用的对象才算完全产生出来。

### 对象的内存布局

- 对象头
- 实例数据
- 对齐填充

#### 对象头

![1563696696713](assets/JVM 内存/1563696696713.png)

> 如果是数组对象,对象头会有length

- markword

  这个单独讲可以讲好久,只是提一下

  ![1563696735325](assets/JVM 内存/1563696735325.png)

- 类型指针kclass

  对象头的另外一部分是类型指针,即对象指向它的类元数据的指针,虚拟机通过这个指针来确定这个对象是哪个类的实例。

  并不是所有的虚拟机实现都必须在对象数据上保留类型指针,换句话说,查找对象的元数据信息并不一定要经过对象本身,比如使用句柄

#### 实例数据

这个没什么好说的

#### 对齐填充

对齐填充并不是必然存在的,也没有特别的含义,它仅仅起着占位符的作用。
由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍,换句话说,就是对象的大小必须是8字节的整数倍。

### 对象的访问定位

建立对象是为了使用对象,我们的Java程序需要通过栈上的reference数据来操作堆上的具体对象。由于reference类型在**Java虚拟机规范中只规定了一个指向对象的引用,并没有定义这个引用应该通过何种方式去定位**、访问堆中的对象的具体位置,所以对象访问方式也是取决于虚拟机实现而定的。

目前主流的访问方式有使用句柄和直接指针两种。

#### 句柄

如果使用句柄访问的话,那么Java堆中将会划分出一块内存来作为句柄池,reference中存储的就是对象的句柄地址,而句柄中包含了对象实例数据与类型数据各自的具体地址信息.

![1563696849532](assets/JVM 内存/1563696849532.png)



#### 直接指针(快)

如果使用直接指针访问,那么**Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息**,而reference中存储的直接就是对象地址

![1563696919492](assets/JVM 内存/1563696919492.png)

#### 对比

这两种对象访问方式各有优势,使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址,在对象被移动(垃圾收集时移动对象是非常普遍的行为)时只会改变句柄中的实例数据指针,而reference本身不需要修改。

**使用直接指针访问方式的最大好处就是速度更快,它节省了一次指针定位的时间开销**,由于对象的访问在Java中非常频繁,因此这类开销积少成多后也是一项非常可观的执行成本。就本书讨论的主要虚拟机**Sun HotSpot而言,它是使用第二种方式进行对象访问的**

## 内存溢出

在Java虚拟机规范的描述中**,除了程序计数器外,虚拟机内存的其他几个运行时区域都有发生OutOfMemoryError(下文称OOM)异常的可能**

### 模拟java堆溢出

限制Java堆的大小为20MB,不可扩展(将堆的最小值-Xms参数与最大值-Xmx参数设置为一样即可避免堆自动扩展),通过参数-XX:
+HeapDumpOnOutOfMemoryError可以让虚拟机在出现内存溢出异常时Dump出当前的内存堆转储快照以便事后进行分析 。

```java
/**
 * VM Args:-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError  -XX:HeapDumpPath=./
 */
public class HeapOOM {

    static class OOMObject {
    }

    public static void main(String[] args) {
        List<OOMObject> list = new ArrayList<OOMObject>();
        while (true) {
            list.add(new OOMObject());
        }
    }

}

```

jvisualvm

![image-20190921113714671](assets/JVM 内存/image-20190921113714671.png)



![image-20190921113739383](assets/JVM 内存/image-20190921113739383.png)

### 模拟虚拟机栈和本地方法栈溢出

**由于在HotSpot虚拟机中并不区分虚拟机栈和本地方法栈,**因此,对于HotSpot来说,虽然-Xoss参数(设置本地方法栈大小)存在,但实际上是无效的,栈容量只由-Xss参数设定。



如果线程请求的栈深度大于虚拟机所允许的最大深度,将抛出StackOverflowError异常。
如果虚拟机在扩展栈时无法申请到足够的内存空间,则抛出OutOfMemoryError异常。

### 模拟常量池溢出(1.8)

```java

/**
 * VM Args: -XX:MetaspaceSize=10M -XX:MaxMetaspaceSize=10M   1.7:-XX:PermSize=10M -XX:MaxPermSize=10M
 */
public class RuntimeConstantPoolOOM {
    static String s = "string";
    public static void main(String[] args) {
        //使用List保持着常量池引用，避免Full GC回收常量池行为
        List<String> list = new ArrayList<String>(); //10MB的PermSize在integer范围内足够产生OOM了
        while (true) {
            list.add(String.valueOf(s).intern());
            s += s;
        }
    }
}

```

实际是在Metaspace

### 方法区溢出

大量动态代理类可以模拟.

实际是在Metaspace



### 处理

##### 内存溢出自动导出

-XX:+HeapDumpOnOutOfMemoryError  虚拟机出现OOM的时候·自动生成dump文件。

-XX:HeapDumpPath=./

##### 使用jmap命令手动导出

jmap -dump:format=b,file=heap.hprof 18384

##### 使用MAP工具/jvisualvm工具分析

